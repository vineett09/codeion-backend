const { v4: uuidv4 } = require("uuid");
const DSAUser = require("../models/DSAUser");
const dsaRoomService = require("../services/DSAChallengeRoomService");
const axios = require("axios");

const handleDSAConnection = (io, socket) => {
  console.log("DSA User connected:", socket.id);

  // Helper to send notifications
  const sendNotification = (roomId, type, message) => {
    io.to(roomId).emit("notification", { type, message });
  };

  // Join DSA challenge room
  socket.on("join-dsa-room", async (data) => {
    try {
      const { roomId, userName, sessionId, userEmail } = data;
      const room = dsaRoomService.getRoom(roomId);
      if (!userEmail) {
        socket.emit("error", { message: "User email is required to join." });
        return;
      }
      if (!room) {
        socket.emit("error", { message: "Room not found" });
        return;
      }

      let user;
      let isReconnecting = false;

      if (sessionId) {
        const reconnectedUser = dsaRoomService.reconnectUser(
          roomId,
          sessionId,
          socket.id
        );
        if (reconnectedUser) {
          user = reconnectedUser;
          isReconnecting = true;
          console.log(`${user.name} reconnected to DSA room ${roomId}`);
        }
      }

      if (!isReconnecting) {
        if (room.isFull()) {
          socket.emit("error", { message: "Room is full" });
          return;
        }
        const newSessionId = uuidv4();
        const newUserId = uuidv4();
        user = new DSAUser(
          newUserId,
          userName,
          socket.id,
          newSessionId,
          userEmail
        );
        dsaRoomService.addUserToRoom(roomId, user);
        console.log(`${userName} joined DSA room ${roomId} for the first time`);
      }

      socket.join(roomId);

      const currentUsers = dsaRoomService.getAllUsersInRoom(roomId);
      const roomDataForUser = room.getRoomDataForUser(user.id);

      socket.emit("dsa-room-joined", {
        ...roomDataForUser,
        user: user.toJSON(),
        sessionId: user.sessionId,
        users: currentUsers.map((u) => u.toJSON()),
      });

      const eventType = isReconnecting
        ? "dsa-user-reconnected"
        : "dsa-user-joined";
      socket.to(roomId).emit(eventType, {
        user: user.toJSON(),
        users: currentUsers.map((u) => u.toJSON()),
      });

      // NOTIFICATION
      const notificationMessage = isReconnecting
        ? `${user.name} has reconnected!`
        : `${user.name} has joined the room.`;
      sendNotification(roomId, "info", notificationMessage);

      io.to(roomId).emit("dsa-users-list-sync", {
        users: currentUsers.map((u) => u.toJSON()),
      });
    } catch (error) {
      console.error("Error in join-dsa-room:", error);
      socket.emit("error", { message: error.message });
    }
  });

  socket.on("set-room-topic", (data) => {
    try {
      const user = dsaRoomService.getUserBySocketId(socket.id);
      if (!user) return;

      const { roomId, topic } = data;
      const room = dsaRoomService.getRoom(roomId);

      if (!room) {
        socket.emit("error", { message: "Room not found" });
        return;
      }

      if (room.createdBy !== user.name) {
        socket.emit("error", {
          message: "Only the room creator can set the topic.",
        });
        return;
      }

      room.topic = topic;
      room.lastActivity = new Date();

      io.to(roomId).emit("room-topic-updated", { topic, updatedBy: user.name });

      // NOTIFICATION
      sendNotification(
        roomId,
        "info",
        `Topic changed to '${topic}' by ${user.name}.`
      );

      console.log(`Topic set to '${topic}' in room ${roomId} by ${user.name}`);
    } catch (error) {
      console.error("Error in set-room-topic:", error);
      socket.emit("error", { message: error.message });
    }
  });

  socket.on("generate-challenge", async (data) => {
    try {
      const user = dsaRoomService.getUserBySocketId(socket.id);
      if (!user) return;

      const { roomId, difficulty, topic } = data;
      const room = dsaRoomService.getRoom(roomId);

      if (!room) {
        socket.emit("error", { message: "Room not found" });
        return;
      }

      if (room.createdBy !== user.name && room.users.length > 1) {
        socket.emit("error", {
          message: "Only room creator can generate challenges",
        });
        return;
      }

      const challenge = await dsaRoomService.generateChallenge(
        roomId,
        difficulty,
        topic
      );

      io.to(roomId).emit("new-challenge", {
        challenge: room.currentChallenge,
        generatedBy: user.name,
        room: room.toJSON(),
      });

      // NOTIFICATION
      sendNotification(
        roomId,
        "success",
        `New challenge generated by ${user.name}!`
      );

      console.log(`Challenge generated in room ${roomId} by ${user.name}`);
    } catch (error) {
      console.error("Error in generate-challenge:", error);
      socket.emit("error", { message: error.message });
    }
  });

  socket.on("save-code", (data) => {
    const { roomId, code } = data;
    const user = dsaRoomService.getUserBySocketId(socket.id);
    const room = dsaRoomService.getRoom(roomId);
    if (!room || !user) return;

    room.saveUserCode(user.id, code);

    socket.emit("code-saved", {
      userId: user.id,
      roomId,
      timestamp: new Date(),
    });
  });

  socket.on("submit-solution", async (data) => {
    try {
      const user = dsaRoomService.getUserBySocketId(socket.id);
      if (!user) throw new Error("User session not found");

      const { roomId, solution } = data;
      if (!roomId || !solution || !solution.language || !solution.code) {
        throw new Error("Invalid submission data");
      }

      const result = await dsaRoomService.submitSolution(
        roomId,
        user.id,
        solution
      );

      if (!result.success) {
        throw new Error(result.message || "Submission failed");
      }

      socket.emit("solution-submitted", {
        submission: result.submission,
        message: "Solution submitted successfully",
      });

      socket.to(roomId).emit("user-submitted", {
        userId: user.id,
        userName: user.name,
        submissionId: result.submission.id,
        submittedAt: result.submission.submittedAt,
      });

      // NOTIFICATION
      sendNotification(
        roomId,
        "info",
        `${user.name} has submitted a solution.`
      );

      setTimeout(async () => {
        try {
          const evaluationResult = await dsaRoomService.evaluateSubmission(
            roomId,
            result.submission.id
          );

          if (!evaluationResult.success) {
            throw new Error(evaluationResult.message || "Evaluation failed");
          }

          socket.emit("evaluation-result", {
            submission: evaluationResult.submission,
            testResults: evaluationResult.submission.testResults,
          });

          const leaderboard = dsaRoomService.getLeaderboard(roomId);
          io.to(roomId).emit("leaderboard-updated", {
            leaderboard,
            lastSubmission: {
              userId: user.id,
              userName: user.name,
              status: evaluationResult.submission.status,
              score: evaluationResult.submission.score,
            },
          });

          // NOTIFICATION for evaluation result
          if (evaluationResult.submission.status === "accepted") {
            sendNotification(
              roomId,
              "success",
              `ðŸŽ‰ ${user.name} passed all test cases!`
            );
          } else {
            sendNotification(
              roomId,
              "warning",
              `${user.name}'s submission failed some test cases.`
            );
          }
        } catch (evalError) {
          console.error("Evaluation error:", evalError);
          socket.emit("error", {
            message: evalError.message || "Evaluation failed",
            code: "EVALUATION_ERROR",
            submissionId: result.submission.id,
          });
        }
      }, 2000);
    } catch (error) {
      console.error("Submit solution error:", {
        error: error.message,
        socketId: socket.id,
        stack: error.stack,
        data,
      });
      socket.emit("error", {
        message: error.message || "Failed to submit solution",
        code: "SUBMISSION_ERROR",
        details: {
          roomId: data?.roomId,
          hasCode: !!data?.solution?.code,
          hasLanguage: !!data?.solution?.language,
        },
      });
    }
  });

  socket.on("end-challenge", async (data) => {
    try {
      const user = dsaRoomService.getUserBySocketId(socket.id);
      if (!user) return;

      const { roomId } = data;
      const room = dsaRoomService.getRoom(roomId);

      if (!room) {
        socket.emit("error", { message: "Room not found" });
        return;
      }

      if (room.createdBy !== user.name) {
        socket.emit("error", {
          message: "Only room creator can end challenges",
        });
        return;
      }

      const updatedRoom = dsaRoomService.endChallenge(roomId);
      const finalLeaderboard = dsaRoomService.getLeaderboard(roomId);

      io.to(roomId).emit("challenge-ended", {
        room: updatedRoom.toJSON(),
        finalLeaderboard,
        endedBy: user.name,
      });

      // NOTIFICATION
      sendNotification(
        roomId,
        "warning",
        `The challenge has been ended by ${user.name}.`
      );

      const winner = finalLeaderboard.length > 0 ? finalLeaderboard[0] : null;
      if (winner) {
        sendNotification(
          roomId,
          "success",
          `ðŸ† ${winner.userName} wins the challenge!`
        );
      }

      console.log(`Challenge ended in room ${roomId}. Updating user stats...`);

      try {
        const winner = finalLeaderboard.length > 0 ? finalLeaderboard[0] : null;

        for (const player of room.users) {
          if (!player.email) continue;

          const userSubmissions = room.getUserSubmissions(player.id);
          const acceptedSubmissions = userSubmissions.filter(
            (sub) => sub.status === "accepted"
          );
          const solvedProblems = acceptedSubmissions.map(
            (sub) => sub.challengeId
          );
          const totalScore = acceptedSubmissions.reduce(
            (sum, sub) => sum + (sub.score || 0),
            0
          );

          // Calculate rating change based on performance
          let ratingChange = 0;
          if (winner && player.id === winner.userId) {
            ratingChange = 25; // Winner gets +25
          } else if (acceptedSubmissions.length > 0) {
            ratingChange = 10; // Solved at least one problem +10
          } else {
            ratingChange = -5; // No solutions -5
          }

          // Determine problem difficulties (you'll need to add difficulty to your challenge generation)
          const problemDifficulties = solvedProblems.map(
            () => room.difficulty || "medium"
          );

          const payload = {
            email: player.email,
            stats: {
              won: winner ? player.id === winner.userId : false,
              ratingChange: ratingChange,
              solvedProblems: solvedProblems,
              problemDifficulties: problemDifficulties,
              submissions: userSubmissions.length,
              acceptedSubmissions: acceptedSubmissions.length,
              score: totalScore,
            },
          };

          await axios.post(
            `${process.env.NEXT_APP_URL}/api/user/update-stats`,
            payload,
            {
              headers: {
                "Content-Type": "application/json",
                "x-internal-api-key": process.env.INTERNAL_API_SECRET,
              },
            }
          );
          console.log(`Successfully updated stats for ${player.email}`);
        }
      } catch (apiError) {
        console.error(
          "Failed to update user stats via API:",
          apiError.response ? apiError.response.data : apiError.message
        );
      }
    } catch (error) {
      console.error("Error in end-challenge:", error);
      socket.emit("error", { message: error.message });
    }
  });

  socket.on("get-user-submissions", (data) => {
    try {
      const user = dsaRoomService.getUserBySocketId(socket.id);
      if (!user) return;
      const { roomId, userId } = data;
      const targetUserId = userId || user.id;
      const submissions = dsaRoomService.getUserSubmissions(
        roomId,
        targetUserId
      );
      socket.emit("user-submissions", { userId: targetUserId, submissions });
    } catch (error) {
      console.error("Error in get-user-submissions:", error);
      socket.emit("error", { message: error.message });
    }
  });

  socket.on("get-leaderboard", (data) => {
    try {
      const user = dsaRoomService.getUserBySocketId(socket.id);
      if (!user) return;
      const { roomId } = data;
      const leaderboard = dsaRoomService.getLeaderboard(roomId);
      socket.emit("leaderboard-data", { leaderboard });
    } catch (error) {
      console.error("Error in get-leaderboard:", error);
      socket.emit("error", { message: error.message });
    }
  });

  socket.on("change-language", (data) => {
    try {
      const user = dsaRoomService.getUserBySocketId(socket.id);
      if (!user) return;
      const { roomId, language } = data;
      user.setLanguage(language);
      socket.to(roomId).emit("user-language-changed", {
        userId: user.id,
        userName: user.name,
        language: language,
      });
    } catch (error) {
      console.error("Error in change-language:", error);
      socket.emit("error", { message: error.message });
    }
  });

  socket.on("get-room-info", (data) => {
    try {
      const user = dsaRoomService.getUserBySocketId(socket.id);
      if (!user) return;
      const { roomId } = data;
      const room = dsaRoomService.getRoom(roomId);
      if (!room) {
        socket.emit("error", { message: "Room not found" });
        return;
      }
      socket.emit("room-info", {
        room: room.toJSON(),
        users: dsaRoomService.getAllUsersInRoom(roomId).map((u) => u.toJSON()),
      });
    } catch (error) {
      console.error("Error in get-room-info:", error);
      socket.emit("error", { message: error.message });
    }
  });

  socket.on("disconnect", () => {
    try {
      const disconnectionData = dsaRoomService.handleUserDisconnect(socket.id);
      if (disconnectionData) {
        const { user, roomId } = disconnectionData;
        socket.to(roomId).emit("dsa-user-disconnected", {
          userId: user.id,
          userName: user.name,
          users: dsaRoomService
            .getAllUsersInRoom(roomId)
            .map((u) => u.toJSON()),
        });

        // NOTIFICATION
        sendNotification(roomId, "warning", `${user.name} has disconnected.`);

        console.log(`DSA User ${user.name} disconnected from room ${roomId}`);
      }
    } catch (error) {
      console.error("Error handling disconnect:", error);
    }
  });

  socket.on("leave-room", (data) => {
    try {
      const user = dsaRoomService.getUserBySocketId(socket.id);
      if (!user) return;
      const { roomId } = data;
      dsaRoomService.removeUserPermanently(roomId, user.id);
      socket.leave(roomId);
      socket.to(roomId).emit("dsa-user-left", {
        userId: user.id,
        userName: user.name,
        users: dsaRoomService.getAllUsersInRoom(roomId).map((u) => u.toJSON()),
      });

      // NOTIFICATION
      sendNotification(roomId, "warning", `${user.name} has left the room.`);

      socket.emit("room-left", {
        message: "Successfully left the room",
        roomId,
      });
      console.log(`User ${user.name} left room ${roomId} permanently`);
    } catch (error) {
      console.error("Error in leave-room:", error);
      socket.emit("error", { message: error.message });
    }
  });
};

module.exports = handleDSAConnection;
